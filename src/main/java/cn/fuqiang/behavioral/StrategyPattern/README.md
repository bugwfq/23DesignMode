#策略模式（Strategy Pattern）
        策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装
    到具有共同接口的独立类中，最后委派给不同的对象管理，从而使得它们可以互相
    替换。也就是说策略模式把行为和环境分割开来，环境负责维持查询行为类，各种
    算法则具体的抽象策略的子类(ConcreteStrategy)中提供。由于算法和环境独立开来。
    算法的增减、修改都不会影响环境和客户端，所以策略模式可以使得算法可以在不影
    响到客户端的情况下发生变化。
    
###策略模式的使用场景
        某个场景下我们使用不同的方式来解决当前遇到的问题，这种解决问题的方式我们可以称之为策略。
        在软件开发过程中我们可能会遇到某个功能需要用不同的算法策略去实现，一般的控制方式可能就是 
        if(...){
            ...
        }else if(...){
            ...
        }else{
            ...
        }
        这种方式虽然结构清晰，但是存在很大的弊端，如果处理的方式比较多可能会导致代码过于臃肿，而且
    不断地去修改代码也是违背了开闭原则，所以策略模式出现了。
###策略模式的结构

    策略又称做政策(Policy)模式。 这个模式涉及到三个角色： 
  * 环境(Context)角色：持有一个抽象策略(Strategy)类的引用 
  * 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略
 所需的接口，也就是说定义一个抽象策略由子类去具体实现
  * 具体策略(ConcreteStrategy)角色： 包装了相关的算法或行为
  
###策略模式的意义
        策略模式可以使得某个部分的组成更加灵活，使得各部分为弱连接关系。而且弱连接的特性使软件具有更强
    的可扩展性、易维护性更是大大的提高了软件的可重用性
###JDK中的策略模式
    Comparator 比较策略 
        在不同业务下同一个对象可能会以不同情况去排序，如果我们把这种排序规则写死的话呢么后期减少或增加
    业务就需要不断地修改或删除代码，如果我们使用策略模式去解决，就可以在不影响原代码的情况下减少或增加
    例如：
    实现抽象策略接口  按照年龄排序策略
    class ComparaByUserAge implements Comparator<User>{
        @Override
        public int compare(User o1, User o2) {
            return o1.age-o2.age ;
        }
    }
    实现抽象策略接口  按照名称排序策略
    class ComparaByUserName implements Comparator<User>{
        @Override
        public int compare(User o1, User o2) {
            return o1.name.compareTo(o2.name) ;
        }
    }
    如果后期有添加user字段，就可以再重写一个策略类
    在使用的时候就可以 ：
    Collections.sort(list,new ComparaByUserAge());直接使用
###策略模式的缺点
    1.不断地去重写会生成很多的策略类
    2.只有知道具体的策略类名才可以使用(在不封装的情况下)
